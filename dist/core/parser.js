"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _definitions = _interopRequireDefault(require("./definitions.js"));

var _color = _interopRequireDefault(require("./color.js"));

var _fontMetrics = _interopRequireDefault(require("./fontMetrics.js"));

var _lexer = _interopRequireDefault(require("./lexer.js"));

var _mathAtom = _interopRequireDefault(require("./mathAtom.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MathAtom = _mathAtom.default.MathAtom;
/**
 * A parser transforms a list of tokens into a list of MathAtom.
 *
 * @param {Token[]} tokens - An array of tokens generated by the lexer.
 * @param {Object.<string>} [args] - An optional list of arguments. `#n` tokens will be
 * substituted with the corresponding element in the args object. This is used
 * when parsing macros.
 * @class module:core/parser#Parser
 * @property {Object.<string, string>} [macros] - Optional macro definitions.
 * @property {Token[]} tokens - An array of tokens generated by the lexer.
 * @property {Object.<string>} args - Optional arguments to substitute the `#` token.
 * @property {Object.<string, string>} macros - A dictionary of objects, index by the name of
 * the macro, with the following keys:
 *    * args: an integer, the number of arguments, default 0. They can be referenced as #0,
 *       #1, #2... inside the definition of the macro
 *    * def: a string, the definition of the macro, which can reference other macros
 * @property {number} index - The current token to be parsed: index in `this.tokens`
 * @property {MathAtom[]} mathList - Accumulated result of the parsing by
 * `parseAtom()`
 * @property {object} style - The font, weight, color, etc.. to apply to the 
 * upcoming tokens
 * @property {string} parseMode - The parse mode indicates the syntax rules to
 * use to parse the upcoming tokens.
 *  Valid values include:
 *  - `'math'`: spaces are ignored, math functions are allowed
 *  - `'text'`: spaces are accounted for, math functions are ignored
 *  - `'string'`
 *  - `'color'`: color name, hex value: `'#fff'`, `'#a0a0a0'`
 *  - `'number'`: `+/-12.56`
 *  - `'dimen'`: `'25mu'`, `'2pt'`
 *  - `'skip'`: `'25mu plus 2em minus fiLll'`, `'2pt'`
 *  - `'colspec'`: formating of a column in tabular environment, e.g. `'r@{.}l'`
 * @property {boolean} tabularMode - When in tabular mode, `'&'` is interpreted as
 *  a column separator and `'\'` as a row separator. Used for matrixes, etc...
 * @property {number} endCount - Counter to prevent deadlock. If `end()` is
 * called too many times (1,000) in a row for the same token, bail.
 * @private
 */

var Parser =
/*#__PURE__*/
function () {
  function Parser(tokens, args, macros) {
    _classCallCheck(this, Parser);

    this.tokens = tokens;
    this.index = 0;
    this.args = args;
    this.macros = macros;
    this.mathList = [];
    this.style = {};
    this.parseMode = 'math';
    this.tabularMode = false;
    this.endCount = 0;
  }

  _createClass(Parser, [{
    key: "swapMathList",
    value: function swapMathList(newMathList) {
      var result = this.mathList;
      this.mathList = newMathList || [];
      return result;
    }
  }, {
    key: "swapParseMode",
    value: function swapParseMode(mode) {
      var result = this.parseMode;
      this.parseMode = mode;
      return result;
    }
    /**
     * True if we've reached the end of the token stream.
     * @method module:core/parser#Parser#end
     * @private
     */

  }, {
    key: "end",
    value: function end() {
      // To prevent a deadlock, count how many times end() is called without the
      // index advancing. If it happens more than 1,000 times in a row,
      // assume something is broken and pretend the stream is finished.
      this.endCount++;
      return this.index >= this.tokens.length || this.endCount > 1000;
    }
  }, {
    key: "get",
    value: function get() {
      this.endCount = 0;
      return this.index < this.tokens.length ? this.tokens[this.index++] : null;
    }
  }, {
    key: "peek",
    value: function peek(offset) {
      var index = this.index + (offset ? offset : 0);
      return index < this.tokens.length ? this.tokens[index] : null;
    }
    /**
     * Return the last atom of the math list
     * If there isn't one, insert a `msubsup` and return it.
     * @method Parser#lastMathAtom
     */

  }, {
    key: "lastMathAtom",
    value: function lastMathAtom() {
      var lastType = this.mathList.length === 0 ? 'none' : this.mathList[this.mathList.length - 1].type;

      if (lastType !== 'mop' && lastType !== 'msubsup') {
        // ZERO WIDTH SPACE
        var lastAtom = new MathAtom(this.parseMode, 'msubsup', "\u200B");
        lastAtom.attributes = {
          'aria-hidden': true
        };
        this.mathList.push(lastAtom);
      }

      return this.mathList[this.mathList.length - 1];
    }
    /**
     * @param {string} type
     * @return {boolean} True if the next token is of the specified type
     * @method module:core/parser#Parser#hasToken
     */

  }, {
    key: "hasToken",
    value: function hasToken(type) {
      var index = this.index;
      return index < this.tokens.length ? this.tokens[index].type === type : false;
    }
    /**
     * @param {string} [value]
     * @return {boolean} True if the next token is of type `'literal` and has the
     * specified value. If `value` is empty, return true if the token is of type
     * `'literal'`
     * @method Parser#hasLiteral
     */

  }, {
    key: "hasLiteral",
    value: function hasLiteral(value) {
      var index = this.index;
      return index < this.tokens.length ? this.tokens[index].type === 'literal' && (!value || this.tokens[index].value === value) : false;
    }
    /**
     * @param {RegEx} pattern
     * @return {boolean} True if the next token is of type `'literal` and matches
     * the specified regular expression pattern.
     * @method module:core/parser#Parser#hasLiteralPattern
     */

  }, {
    key: "hasLiteralPattern",
    value: function hasLiteralPattern(pattern) {
      return this.hasToken('literal') && pattern.test(this.tokens[this.index].value);
    }
  }, {
    key: "hasCommand",
    value: function hasCommand(command) {
      console.assert(command === '\\' || command.charAt(0) !== '\\', 'hasCommand() does not require a \\');
      var index = this.index;
      return index < this.tokens.length ? this.tokens[index].type === 'command' && this.tokens[index].value === command : false;
    }
  }, {
    key: "hasInfixCommand",
    value: function hasInfixCommand() {
      var index = this.index;

      if (index < this.tokens.length && this.tokens[index].type === 'command') {
        var info = _definitions.default.getInfo('\\' + this.tokens[index].value, this.parseMode, this.macros);

        return info && info.infix;
      }

      return false;
    }
  }, {
    key: "hasColumnSeparator",
    value: function hasColumnSeparator() {
      var index = this.index;
      return this.tabularMode && index < this.tokens.length ? this.tokens[index].type === 'literal' && this.tokens[index].value === '&' : false;
    }
  }, {
    key: "hasRowSeparator",
    value: function hasRowSeparator() {
      var index = this.index;
      return this.tabularMode && index < this.tokens.length ? this.tokens[index].type === 'command' && (this.tokens[index].value === '\\' || this.tokens[index].value === 'cr') : false;
    }
  }, {
    key: "parseColumnSeparator",
    value: function parseColumnSeparator() {
      if (this.hasColumnSeparator()) {
        this.index++;
        return true;
      }

      return false;
    }
    /**
     * Return the appropriate value for a placeholder, either a default
     * one, or if a value was provided for #? via args, that value.
     */

  }, {
    key: "placeholder",
    value: function placeholder() {
      if (this.args && typeof this.args['?'] === 'string') {
        // If there is a specific value defined for the placeholder,
        // use it.
        return parseTokens(_lexer.default.tokenize(this.args['?']), this.parseMode, null, this.macros);
      } // U+2753 = BLACK QUESTION MARK ORNAMENT


      var result = new MathAtom(this.parseMode, 'placeholder', '?', this.style);
      result.captureSelection = true;
      return [result];
    }
  }, {
    key: "hasImplicitCommand",
    value: function hasImplicitCommand(commands) {
      if (this.index < this.tokens.length) {
        var token = this.tokens[this.index];

        if (token.type === 'command') {
          return commands.includes(token.value);
        }
      }

      return false;
    }
  }, {
    key: "parseRowSeparator",
    value: function parseRowSeparator() {
      if (this.hasRowSeparator()) {
        this.index++;
        return true;
      }

      return false;
    }
    /**
     * @param {string} type
     * @method module:core/parser#Parser#parseToken
     */

  }, {
    key: "parseToken",
    value: function parseToken(type) {
      if (this.hasToken(type)) {
        this.index++;
        return true;
      }

      return false;
    }
  }, {
    key: "skipWhitespace",
    value: function skipWhitespace() {
      var found = false;

      while (this.hasToken('space')) {
        this.index++;
        found = true;
      }

      return found;
    }
  }, {
    key: "skipUntilToken",
    value: function skipUntilToken(type) {
      while (!this.end() && !this.parseToken(type)) {
        this.get();
      }
    }
  }, {
    key: "parseCommand",
    value: function parseCommand(command) {
      if (this.hasCommand(command)) {
        this.index++;
        return true;
      }

      return false;
    }
  }, {
    key: "parseLiteral",
    value: function parseLiteral(literal) {
      if (this.hasLiteral(literal)) {
        this.index++;
        return true;
      }

      return false;
    }
  }, {
    key: "parseFiller",
    value: function parseFiller() {
      var skipped = false;
      var done = false;

      do {
        var skippedSpace = this.skipWhitespace();
        var skippedRelax = this.parseCommand('relax');
        skipped = skipped || skippedSpace || skippedRelax;
        done = !skippedSpace && !skippedRelax;
      } while (!done);

      return skipped;
    }
    /**
     * Keywords are used to specify dimensions, and for various other
     * syntactic constructs. Unlike commands, they are not case sensitive.
     * There are 25 keywords:
     * at by bp cc cm dd depth em ex fil fill filll height in minus
     * mm mu pc plus pt sp spread to true width
     *
     * TeX: 8212
     * @param {string} keyword
     * @return {boolean} true if the expected keyword is present
     * @method module:core/parser#Parser#parseKeyword
     * @private
     */

  }, {
    key: "parseKeyword",
    value: function parseKeyword(keyword) {
      var savedIndex = this.index;
      var done = this.end();
      var value = '';

      while (!done) {
        var token = this.get();

        if (token.type === 'literal') {
          value += token.value;
        }

        done = this.end() || token.type !== 'literal' || value.length >= keyword.length;
      }

      var hasKeyword = keyword.toUpperCase() === value.toUpperCase();

      if (!hasKeyword) {
        this.index = savedIndex;
      }

      return hasKeyword;
    }
    /**
     * Return a sequence of characters as a string.
     * i.e. 'abcd' returns 'abcd'.
     * Terminates on the first non-character encountered
     * e.g. '{', '}' etc...
     * Will also terminate on ']'
     * @return {string}
     * @method module:core/parser#Parser#scanString
     * @private
     */

  }, {
    key: "scanString",
    value: function scanString() {
      var result = '';
      var done = this.end();

      while (!done) {
        if (this.hasLiteral(']')) {
          done = true;
        } else if (this.hasToken('literal')) {
          result += this.get().value;
        } else if (this.skipWhitespace()) {
          result += ' ';
        } else if (this.hasToken('command')) {
          var token = this.get();

          if (token.value === 'space') {
            // The 'space' command is the ~
            // which can be used for example in operator names, i.e.
            // \operatorname{lim~inf}. It's interpreted as a nbs
            result += "\xA0"; // NO-BREAK SPACE
          } else {
            // TeX will give a 'Missing \endcsname inserted' error
            // if it encounters any command when expecting a string.
            // We're a bit more lax.
            result += token.value;
          }
        } else {
          done = true;
        }

        done = done || this.end();
      }

      return result;
    }
    /**
     * Return a CSS color (#rrggbb)
     * @method module:core/parser#Parser#scanColor
     * @private
     */

  }, {
    key: "scanColor",
    value: function scanColor() {
      return _color.default.stringToColor(this.scanString());
    }
    /**
     * Return as a number a group of characters representing a
     * numerical quantity.
     *
     * From TeX:8695 (scan_int):
     * An integer number can be preceded by any number of spaces and `\.+' or
     * `\.-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * octal constant (i.e., radix 8, preceded by~\.\'), a hexadecimal constant
     * (radix 16, preceded by~\."), an alphabetic constant (preceded by~\.\`), or
     * an internal variable.
     * @return {number}
     * @method Parser#scanNumber
     * @private
     */

  }, {
    key: "scanNumber",
    value: function scanNumber(isInteger) {
      var negative = this.parseLiteral('-'); // Optional (ignorable) '+' sign

      if (!negative) this.parseLiteral('+');
      this.skipWhitespace();
      isInteger = !!isInteger;
      var radix = 10;
      var digits = /[0-9]/;

      if (this.parseLiteral("'")) {
        // Apostrophe indicates an octal value
        radix = 8;
        digits = /[0-7]/;
        isInteger = true;
      } else if (this.parseLiteral('"') || this.parseLiteral('x')) {
        // Double-quote indicates a hex value
        // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
        // For example: 'x3a'
        radix = 16; // Hex digits have to be upper-case

        digits = /[0-9A-F]/;
        isInteger = true;
      }

      var value = '';

      while (this.hasLiteralPattern(digits)) {
        value += this.get().value;
      } // Parse the fractional part, if applicable


      if (!isInteger && (this.parseLiteral('.') || this.parseLiteral(','))) {
        value += '.';

        while (this.hasLiteralPattern(digits)) {
          value += this.get().value;
        }
      }

      var result = isInteger ? parseInt(value, radix) : parseFloat(value);
      return negative ? -result : result;
    }
    /**
     * Return as a floating point number a dimension in pt (1 em = 10 pt)
     *
     * See TeX:8831
     * @todo: note that some units depend on the font (em, ex). So it might be
     * better to return a dimen struct with the value + unit and resolve
     * later when we have a font context....
     * @return {number}
     * @method module:core/parser#Parser#scanDimen
     * @private
     */

  }, {
    key: "scanDimen",
    value: function scanDimen() {
      var value = this.scanNumber(false);
      this.skipWhitespace();
      var result;

      if (this.parseKeyword('pt')) {
        result = _fontMetrics.default.toEm(value, 'pt');
      } else if (this.parseKeyword('mm')) {
        result = _fontMetrics.default.toEm(value, 'mm');
      } else if (this.parseKeyword('cm')) {
        result = _fontMetrics.default.toEm(value, 'cm');
      } else if (this.parseKeyword('ex')) {
        result = _fontMetrics.default.toEm(value, 'ex');
      } else if (this.parseKeyword('px')) {
        result = _fontMetrics.default.toEm(value, 'px');
      } else if (this.parseKeyword('em')) {
        result = _fontMetrics.default.toEm(value, 'em');
      } else if (this.parseKeyword('bp')) {
        result = _fontMetrics.default.toEm(value, 'bp');
      } else if (this.parseKeyword('dd')) {
        result = _fontMetrics.default.toEm(value, 'dd');
      } else if (this.parseKeyword('pc')) {
        result = _fontMetrics.default.toEm(value, 'pc');
      } else if (this.parseKeyword('in')) {
        result = _fontMetrics.default.toEm(value, 'in');
      } else if (this.parseKeyword('mu')) {
        result = _fontMetrics.default.toEm(value, 'mu');
      } else {
        // If the units are missing, TeX assumes 'pt'
        result = _fontMetrics.default.toEm(value, 'pt');
      }

      return result;
    }
  }, {
    key: "scanSkip",
    value: function scanSkip() {
      var result = this.scanDimen(); // We parse, but ignore the optional 'plus' and 'minus'
      // arguments.

      this.skipWhitespace(); // 'plus', optionally followed by 'minus'
      // ('minus' cannot come before 'plus')
      // dimen or 'hfill'

      if (this.parseKeyword('plus')) {
        // @todo there could also be a \hFilLlL command here
        this.scanDimen();
      }

      this.skipWhitespace();

      if (this.parseKeyword('minus')) {
        // @todo there could also be a \hFilLlL command here
        this.scanDimen();
      }

      return result;
    }
  }, {
    key: "scanColspec",
    value: function scanColspec() {
      this.skipWhitespace();
      var result = [];

      while (!this.end() && !(this.hasToken('}') || this.hasLiteral(']'))) {
        if (this.hasLiteral()) {
          var literal = this.get().value;

          if ('lcr'.includes(literal)) {
            result.push({
              align: literal
            });
          } else if (literal === '|') {
            result.push({
              rule: true
            });
          } else if (literal === '@') {
            if (this.parseToken('{')) {
              var savedParsemode = this.swapParseMode('math');
              result.push({
                gap: this.scanImplicitGroup(function (token) {
                  return token.type === '}';
                })
              });
              this.swapParseMode(savedParsemode);
            }

            this.parseToken('}');
          }
        }
      }

      return result;
    }
    /**
     * Parse a `\(...\)` or `\[...\]` sequence
     * @return {MathAtom} group for the sequence or null
     * @method module:core/parser#Parser#scanModeSet
     * @private
     */

  }, {
    key: "scanModeSet",
    value: function scanModeSet() {
      var final;
      if (this.parseCommand('(')) final = ')';
      if (!final && this.parseCommand('[')) final = ']';
      if (!final) return null;
      var savedParsemode = this.swapParseMode('math');
      var result = new MathAtom('math', 'group');
      result.mathstyle = final === ')' ? 'textstyle' : 'displaystyle';
      result.body = this.scanImplicitGroup(function (token) {
        return token.type === 'command' && token.value === final;
      });
      this.parseCommand(final);
      this.swapParseMode(savedParsemode);
      if (!result.body || result.body.length === 0) return null;
      return result;
    }
    /**
     * Parse a `$...$` or `$$...$$` sequence
     * @method Parser#scanModeShift
     * @private
     */

  }, {
    key: "scanModeShift",
    value: function scanModeShift() {
      if (!this.hasToken('$') && !this.hasToken('$$')) return null;
      var final = this.get().type;
      var result = new MathAtom('math', 'group');
      result.mathstyle = final === '$' ? 'textstyle' : 'displaystyle';
      result.latexOpen = result.mathstyle === 'textstyle' ? '$' : '$$';
      result.latexClose = result.latexOpen;
      var savedParsemode = this.swapParseMode('math');
      result.body = this.scanImplicitGroup(function (token) {
        return token.type === final;
      });
      this.parseToken(final);
      this.swapParseMode(savedParsemode);
      if (!result.body || result.body.length === 0) return null;
      return result;
    }
    /**
     * Parse a \begin{env}...\end{end} sequence
     * @method module:core/parser#Parser#scanEnvironment
     * @private
     */

  }, {
    key: "scanEnvironment",
    value: function scanEnvironment() {
      // An environment starts with a \begin command
      if (!this.parseCommand('begin')) return null; // The \begin command is immediately followed by the environment
      // name, as a string argument

      var envName = this.scanArg('string');

      var env = _definitions.default.getEnvironmentInfo(envName); // If the environment has some arguments, parse them


      var args = [];

      if (env && env.params) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = env.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var param = _step.value;

            // Parse an argument
            if (param.optional) {
              // If it's not present, return the default argument value
              var arg = this.scanOptionalArg(param.type); // args.push(arg ? arg : param.defaultValue); @todo defaultvalue

              args.push(arg);
            } else {
              // If it's not present, scanArg returns null,
              // but push it on the list of arguments anyway.
              // The null value will be interpreted as unspecified
              // optional value by the command parse function.
              args.push(this.scanArg(param.type));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } // Some environments change the mode


      var savedMode = this.parseMode;
      var savedTabularMode = this.tabularMode;
      var savedMathList = this.swapMathList([]); // @todo: since calling scanImplicitGroup(), may not need to save/restore the mathlist

      this.tabularMode = env.tabular;
      var array = [];
      var rowGaps = [];
      var row = [];
      var done = false;

      do {
        done = this.end();

        if (!done && this.parseCommand('end')) {
          done = this.scanArg('string') === envName;
        }

        if (!done) {
          if (this.parseColumnSeparator()) {
            row.push(this.swapMathList([]));
          } else if (this.parseRowSeparator()) {
            row.push(this.swapMathList([]));
            var gap = 0;
            this.skipWhitespace();

            if (this.parseLiteral('[')) {
              gap = this.scanDimen();
              this.skipWhitespace();
              this.parseLiteral(']');
            }

            rowGaps.push(gap || 0);
            array.push(row);
            row = [];
          } else {
            this.mathList = this.mathList.concat(this.scanImplicitGroup());
          }
        }
      } while (!done);

      row.push(this.swapMathList([]));
      if (row.length > 0) array.push(row);
      var newMathList = this.swapMathList(savedMathList); // If we're in tabular mode, we should end up with an empty mathlist

      console.assert(!this.tabularMode || newMathList.length === 0, 'Leftover atoms in tabular mode');
      this.parseMode = savedMode;
      this.tabularMode = savedTabularMode;
      if (!env.tabular && newMathList.length === 0) return null;
      if (env.tabular && array.length === 0) return null;
      var result = new MathAtom(this.parseMode, 'array', newMathList, env.parser ? env.parser(envName, args, array) : {});
      result.array = array;
      result.rowGaps = rowGaps;
      result.env = _objectSpread({}, env);
      result.env.name = envName;
      return result;
    }
    /**
     * Parse a sequence terminated with a group end marker, such as
     * `}`, `\end`, `&`, etc...
     * 
     * Returns an array of atoms or an empty array if the sequence
     * terminates right away.
     * 
     * @param {function(Token):boolean} [done] A predicate indicating if a 
     * token signals the end of an implicit group
     * @return {MathAtom[]}
     * @method module:core/parser#Parser#scanImplicitGroup
     * @private
     */

  }, {
    key: "scanImplicitGroup",
    value: function scanImplicitGroup(done) {
      // An implicit group is a sequence of atoms that terminates with
      // a `'}'`, `'&'`, `'\'`, `'\cr'` or `'\end'` or the end of the stream
      var savedStyle = this.style;

      if (!done) {
        done = function done(token) {
          return token.type === '}' || token.type === 'literal' && token.value === '&' || token.type === 'command' && /^(end|cr|\\)$/.test(token.value);
        };
      } // To handle infix operators, we'll keep track of their prefix
      // (tokens coming before them)


      var infix = null; // A token

      var prefix = null; // A mathlist

      var savedMathlist = this.swapMathList([]); // if (this.index >= this.tokens.length) return true;
      // const token = this.tokens[this.index];

      while (!this.end() && !done(this.peek())) {
        if (this.hasImplicitCommand(['displaystyle', 'textstyle', 'scriptstyle', 'scriptscriptstyle'])) {
          // Implicit math style commands such as \displaystyle, \textstyle...
          // Note these commands switch to math mode and a specific size
          // \textsize is the mathstyle used for inlinemath, not for text
          this.parseMode = 'math';
          var atom = new MathAtom('math', 'mathstyle');
          atom.mathstyle = this.get().value;
          this.mathList.push(atom);
        } else if (this.hasInfixCommand() && !infix) {
          // The next token is an infix and we have not seen one yet
          // (there can be only one infix command per implicit group).
          infix = this.get(); // Save the math list so far and start a new one

          prefix = this.swapMathList([]);
        } else {
          this.parseAtom();
        }
      }

      var result;

      if (infix) {
        var suffix = this.swapMathList(savedMathlist); // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode

        var info = _definitions.default.getInfo('\\' + infix.value, 'math', this.macros);

        if (info) {
          result = [new MathAtom(this.parseMode, info.type, info.value || infix.value, // Functions don't have
          info.parse ? info.parse('\\' + infix.value, [prefix, suffix]) : null)];
        } else {
          result = [new MathAtom(this.parseMode, 'mop', infix.value)];
        }
      } else {
        result = this.swapMathList(savedMathlist);
      }

      this.style = savedStyle;
      return result;
    }
    /**
     * Parse a group enclosed in a pair of braces: `{...}`.
     *
     * Return either a group MathAtom or null if not a group.
     *
     * Return a group MathAtom with an empty body if an empty
     * group (i.e. `{}`).
     * @return {MathAtom}
     * @method module:core/parser#Parser#scanGroup
     * @private
     */

  }, {
    key: "scanGroup",
    value: function scanGroup() {
      if (!this.parseToken('{')) return null;
      var result = new MathAtom(this.parseMode, 'group');
      result.body = this.scanImplicitGroup(function (token) {
        return token.type === '}';
      });
      this.parseToken('}');
      result.latexOpen = '{';
      result.latexClose = '}';
      return result;
    }
  }, {
    key: "scanSmartFence",
    value: function scanSmartFence() {
      this.skipWhitespace();
      if (!this.parseLiteral('(')) return null; // We've found an open paren... Convert to a `\mleft...\mright`

      var result = new MathAtom(this.parseMode, 'leftright');
      result.leftDelim = '(';
      result.inner = false; // It's a `\mleft`, not a `\left`

      var savedMathList = this.swapMathList([]);
      var nestLevel = 1;

      while (!this.end() && nestLevel !== 0) {
        if (this.hasLiteral('(')) nestLevel += 1;
        if (this.hasLiteral(')')) nestLevel -= 1;
        if (nestLevel !== 0) this.parseAtom();
      }

      if (nestLevel === 0) this.parseLiteral(')');
      result.rightDelim = nestLevel === 0 ? ')' : '?';
      result.body = this.swapMathList(savedMathList);
      return result;
    }
    /**
     * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
     *
     * @return {string} The delimiter (as a character or command) or null
     * @memberof Parser
     * @method module:core/parser#Parser#scanDelim
     * @private
     */

  }, {
    key: "scanDelim",
    value: function scanDelim() {
      this.skipWhitespace();
      var token = this.get();
      if (!token) return null;
      var delim = '.';

      if (token.type === 'command') {
        delim = '\\' + token.value;
      } else if (token.type === 'literal') {
        delim = token.value;
      }

      var info = _definitions.default.getInfo(delim, 'math', this.macros);

      if (!info) return null;

      if (info.type === 'mopen' || info.type === 'mclose') {
        return delim;
      } // Some symbols are not of type mopen/mclose, but are still
      // valid delimiters...
      // '?' is a special delimiter used as a 'placeholder'
      // (when the closing delimiter is displayed greyed out)


      if (/^(\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(delim)) {
        return delim;
      }

      return null;
    }
    /**
     * Parse a `/left.../right` sequence.
     *
     * Note: the `/middle` command can occur multiple times inside a
     * `/left.../right` sequence, and is handled separately.
     *
     * Return either an atom of type `'leftright'` or null
     * @return {MathAtom}
     * @method module:core/parser#Parser#scanLeftRight
     * @private
     */

  }, {
    key: "scanLeftRight",
    value: function scanLeftRight() {
      if (this.parseCommand('right') || this.parseCommand('mright')) {
        // We have an unbalanced left/right (there's a \right, but no \left)
        var _result = new MathAtom(this.parseMode, 'leftright');

        _result.rightDelim = this.scanDelim() || '.';
        return _result;
      }

      var savedStyle = this.style;
      var close = 'right';

      if (!this.parseCommand('left')) {
        if (!this.parseCommand('mleft')) return null;
        close = 'mright';
      }

      var leftDelim = this.scanDelim() || '.';
      var savedMathList = this.swapMathList([]);

      while (!this.end() && !this.parseCommand(close)) {
        this.parseAtom();
      }

      this.style = savedStyle; // If we've reached the end and there was no `\right` or
      // there isn't a valid delimiter after `\right`, we'll
      // consider the `\right` missing and set the `rightDelim` to undefined

      var rightDelim = this.scanDelim();
      var result = new MathAtom(this.parseMode, 'leftright');
      result.leftDelim = leftDelim;
      result.rightDelim = rightDelim;
      result.inner = close === 'right';
      result.body = this.swapMathList(savedMathList);
      return result;
    }
    /**
     * Parse a subscript/superscript: `^` and `_`.
     *
     * Modify the last atom accordingly.
     *
     * @return {MathAtom}
     * @method module:core/parser#Parser#parseSupSub
     * @private
     */

  }, {
    key: "parseSupSub",
    value: function parseSupSub() {
      // No sup/sub in text or command mode.
      if (this.parseMode !== 'math') return false; // Apply the subscript/superscript to the last render atom.
      // If none is present (beginning of the mathlist, i.e. `{^2}`,
      // an empty atom will be created, equivalent to `{{}^2}`

      var result = false;

      while (this.hasLiteral('^') || this.hasLiteral('_') || this.hasLiteral("'")) {
        var supsub = void 0;

        if (this.hasLiteral('^')) {
          supsub = 'superscript';
        } else if (this.hasLiteral('_')) {
          supsub = 'subscript';
        }

        if (this.parseLiteral('^') || this.parseLiteral('_')) {
          var arg = this.scanArg();

          if (arg) {
            var atom = this.lastMathAtom();
            atom[supsub] = atom[supsub] || [];
            atom[supsub] = atom[supsub].concat(arg);
            result = true;
          }
        } else if (this.parseLiteral("'")) {
          // A single quote (prime) is actually equivalent to a
          // '^{\prime}'
          var _atom = this.lastMathAtom();

          _atom.superscript = _atom.superscript || [];

          _atom.superscript.push(new MathAtom(_atom.parseMode, 'mord', "\u2032"));

          result = true;
        }
      }

      return result;
    }
    /**
     * Parse a `\limits` or `\nolimits` command.
     *
     * This will change the placement of limits to be either above or below
     * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
     *
     * This overrides the calculation made for the placement, which is usually
     * dependent on the displaystyle (`inlinemath` prefers `\nolimits`, while
     * `displaymath` prefers `\limits`).
     * @method module:core/parser#Parser#parseLimits
     * @private
     */

  }, {
    key: "parseLimits",
    value: function parseLimits() {
      // Note: technically, \limits and \nolimits are only applicable
      // after an operator. However, we apply them in all cases. They
      // will simply be ignored when not applicable (i.e. on a literal)
      // which is actually consistent with TeX.
      if (this.parseCommand('limits')) {
        var lastAtom = this.lastMathAtom();
        lastAtom.limits = 'limits'; // Record that the limits was set through an explicit command
        // so we can generate the appropriate LaTeX later

        lastAtom.explicitLimits = true;
        return true;
      }

      if (this.parseCommand('nolimits')) {
        var _lastAtom = this.lastMathAtom();

        _lastAtom.limits = 'nolimits'; // Record that the limits was set through an explicit command
        // so we can generate the appropriate LaTeX later

        _lastAtom.explicitLimits = true;
        return true;
      }

      return false;
    }
  }, {
    key: "scanOptionalArg",
    value: function scanOptionalArg(parseMode) {
      parseMode = !parseMode || parseMode === 'auto' ? this.parseMode : parseMode;
      this.skipWhitespace();
      if (!this.parseLiteral('[')) return null;
      var savedParseMode = this.parseMode;
      this.parseMode = parseMode;
      var savedMathlist = this.swapMathList();
      var result;

      while (!this.end() && !this.parseLiteral(']')) {
        if (parseMode === 'string') {
          result = this.scanString();
        } else if (parseMode === 'number') {
          result = this.scanNumber();
        } else if (parseMode === 'dimen') {
          result = this.scanDimen();
        } else if (parseMode === 'skip') {
          result = this.scanSkip();
        } else if (parseMode === 'colspec') {
          result = this.scanColspec();
        } else if (parseMode === 'color') {
          result = this.scanColor() || '#ffffff';
        } else if (parseMode === 'bbox') {
          // The \bbox command takes a very particular argument:
          // a comma delimited list of up to three arguments:
          // a color, a dimension and a string.
          // Split the string by comma delimited sub-strings, ignoring commas
          // that may be inside (). For example"x, rgb(a, b, c)" would return
          // ['x', 'rgb(a, b, c)']
          var list = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var elem = _step2.value;

              var color = _color.default.stringToColor(elem);

              if (color) {
                result = result || {};
                result.backgroundcolor = color;
              } else {
                var m = elem.match(/^\s*([0-9.]+)\s*([a-z][a-z])/);

                if (m) {
                  result = result || {};
                  result.padding = _fontMetrics.default.toEm(m[1], m[2]);
                } else {
                  var _m = elem.match(/^\s*border\s*:\s*(.*)/);

                  if (_m) {
                    result = result || {};
                    result.border = _m[1];
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          console.assert(parseMode === 'math', 'Unexpected parse mode: "' + parseMode + '"');
          this.mathList = this.mathList.concat(this.scanImplicitGroup(function (token) {
            return token.type === 'literal' && token.value === ']';
          }));
        }
      }

      this.parseMode = savedParseMode;
      var mathList = this.swapMathList(savedMathlist);
      return result ? result : mathList;
    }
    /**
     * Parse a math field, an argument to a function.
     *
     * An argument can either be a single atom or
     * a sequence of atoms enclosed in braces.
     *
     * @param {string} [parseMode] Temporarily overrides the parser parsemode. For
     * example: `'dimension'`, `'color'`, `'text'`, etc...
     * @method module:core/parser#Parser#scanArg
     * @private
     */

  }, {
    key: "scanArg",
    value: function scanArg(parseMode) {
      parseMode = !parseMode || parseMode === 'auto' ? this.parseMode : parseMode;
      this.parseFiller();
      var result; // An argument (which is called a 'math field' in TeX)
      // could be a single character or symbol, as in `\frac12`
      // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
      // ``\frac{\sqrt}{-1}{\beta}``

      if (!this.parseToken('{')) {
        if (parseMode === 'delim') {
          return this.scanDelim() || '.';
        } else if (/^(math|text)$/.test(parseMode)) {
          // Parse a single atom.
          var _savedParseMode = this.parseMode;
          this.parseMode = parseMode;
          var atom = this.scanToken();
          this.parseMode = _savedParseMode;
          if (Array.isArray(atom)) return atom;
          return atom ? [atom] : null;
        }
      } // If this is a param token, substitute it with the
      // (optional) argument passed to the parser


      if (this.hasToken('#')) {
        var paramToken = this.get();
        this.skipUntilToken('}');

        if (paramToken.value === '?') {
          return this.placeholder();
        }

        if (this.args) {
          if (this.args[paramToken.value] === undefined && this.args['?'] !== undefined) {
            return this.placeholder();
          }

          return this.args[paramToken.value] || null;
        }

        return null;
      }

      var savedParseMode = this.parseMode;
      this.parseMode = parseMode;
      var savedMathList = this.swapMathList([]);

      if (parseMode === 'string') {
        result = this.scanString();
        this.skipUntilToken('}');
      } else if (parseMode === 'number') {
        result = this.scanNumber();
        this.skipUntilToken('}');
      } else if (parseMode === 'dimen') {
        result = this.scanDimen();
        this.skipUntilToken('}');
      } else if (parseMode === 'skip') {
        result = this.scanSkip();
        this.skipUntilToken('}');
      } else if (parseMode === 'colspec') {
        result = this.scanColspec();
        this.skipUntilToken('}');
      } else if (parseMode === 'color') {
        result = this.scanColor() || '#ffffff';
        this.skipUntilToken('}');
      } else if (parseMode === 'delim') {
        result = this.scanDelim() || '.';
        this.skipUntilToken('}');
      } else {
        console.assert(/^(math|text)$/.test(parseMode), 'Unexpected parse mode: "' + parseMode + '"');

        do {
          this.mathList = this.mathList.concat(this.scanImplicitGroup());
        } while (!this.parseToken('}') && !this.end());
      }

      this.parseMode = savedParseMode;
      var mathList = this.swapMathList(savedMathList);
      return result ? result : mathList;
    }
    /**
     * @return {MathAtom[]|MathAtom}
     * @method module:core/parser#Parser#scanToken
     * @private
     */

  }, {
    key: "scanToken",
    value: function scanToken() {
      var token = this.get();
      if (!token) return null;
      var result = null;

      if (token.type === 'space') {
        if (this.parseMode === 'text') {
          result = new MathAtom('text', '', ' ', this.style);
        }
      } else if (token.type === 'placeholder') {
        // RENDER PLACEHOLDER
        result = new MathAtom(this.parseMode, 'placeholder', token.value);
        result.captureSelection = true;
      } else if (token.type === 'command') {
        // RENDER COMMAND
        if (token.value === 'placeholder') {
          result = new MathAtom(this.parseMode, 'placeholder', this.scanArg('string'), this.style);
          result.captureSelection = true;
        } else if (token.value === 'char') {
          // \char has a special syntax and requires a non-braced integer
          // argument
          var codepoint = Math.floor(this.scanNumber(true));

          if (!isFinite(codepoint) || codepoint < 0 || codepoint > 0x10FFFF) {
            codepoint = 0x2753; // BLACK QUESTION MARK
          }

          result = new MathAtom(this.parseMode, this.parseMode === 'math' ? 'mord' : '', String.fromCodePoint(codepoint));
          result.latex = '{\\char"' + ('000000' + codepoint.toString(16)).toUpperCase().substr(-6) + '}';
        } else if (token.value === 'hskip' || token.value === 'kern') {
          // \hskip and \kern have a special syntax and requires a non-braced
          // 'skip' argument
          var width = this.scanSkip();

          if (isFinite(width)) {
            result = new MathAtom(this.parseMode, 'spacing', null, this.style);
            result.width = width;
          }

          result.latex = '\\' + token.value;
        } else {
          result = this.scanMacro(token.value);

          if (!result) {
            var info = _definitions.default.getInfo('\\' + token.value, this.parseMode, this.macros);

            var args = [];
            var argString = ''; // Parse the arguments
            // let mandatoryParamsCount = 0;
            // If explicitGroup is not empty, an explicit group is expected 
            // to follow the command and will be parsed *after* the 
            // command has been processed.
            // This is used for commands such as \textcolor{color}{content}
            // that need to apply the color to the content *after* the 
            // style has been changed.
            // In definitions, this is indicated with a parameter type 
            // of 'auto*'

            var explicitGroup = '';

            if (info && info.params) {
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = info.params[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var param = _step3.value;

                  // Parse an argument
                  if (param.optional) {
                    // If it's not present, return the default argument value
                    var arg = this.scanOptionalArg(param.type); // args.push(arg ? arg : param.defaultValue); @todo defaultvalue

                    args.push(arg);
                  } else if (param.type.endsWith('*')) {
                    explicitGroup = param.type.slice(0, -1);
                  } else {
                    // mandatoryParamsCount += 1;
                    // If it's not present, scanArg returns null.
                    // Add a placeholder instead.
                    var _arg = this.scanArg(param.type);

                    if (_arg && _arg.length === 1 && _arg[0].type === 'placeholder' && param.placeholder) {
                      _arg[0].value = param.placeholder;
                    }

                    if (_arg) {
                      args.push(_arg);
                    } else if (param.placeholder) {
                      var placeholder = new MathAtom(this.parseMode, 'placeholder', param.placeholder);
                      placeholder.captureSelection = true;
                      args.push([placeholder]);
                    } else {
                      args.push(this.placeholder());
                    }

                    if (param.type !== 'math' && typeof _arg === 'string') {
                      argString += _arg;
                    }
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }

            if (info && !info.infix) {
              // Infix commands should be handled in scanImplicitGroup
              // If we find an infix command here, it's a syntax error
              // (second infix command in an implicit group) and should be ignored.
              // Create the MathAtom.
              // If a parse function is present, invoke it with the arguments,
              // and pass the result to be appended by the constructor.
              if (info.parse) {
                var attributes = info.parse('\\' + token.value, args);

                if (!attributes.type) {
                  // No type provided -> the parse function will modify
                  // the current style rather than create a new Atom.
                  var savedMode = this.parseMode;

                  if (attributes.mode) {
                    // Change to 'text' (or 'math') mode if necessary
                    this.parseMode = attributes.mode;
                    delete attributes.mode;
                  } // If an explicit group is expected, process it now


                  if (explicitGroup) {
                    // Create a temporary style
                    var saveStyle = this.style;
                    this.style = _objectSpread({}, this.style, attributes);
                    result = this.scanArg(explicitGroup);
                    this.style = saveStyle;
                  } else {
                    // Merge the new style info with the current style
                    this.style = _objectSpread({}, this.style, attributes);
                  }

                  this.parseMode = savedMode;
                } else {
                  result = new MathAtom(this.parseMode, info.type, explicitGroup ? this.scanArg(explicitGroup) : null, _objectSpread({}, this.style, attributes));
                }
              } else {
                var style = _objectSpread({}, this.style);

                if (info.baseFontFamily) style.baseFontFamily = info.baseFontFamily;
                result = new MathAtom(this.parseMode, info.type || 'mop', info.value || token.value, style);

                if (info.skipBoundary) {
                  result.skipBoundary = true;
                }
              }

              if (result && !/^(llap|rlap|class|cssId)$/.test(token.value)) {
                result.latex = '\\' + token.value;

                if (argString
                /*|| mandatoryParamsCount > 0*/
                ) {
                    result.latex += '{' + argString + '}';
                  }

                if (result.isFunction && this.smartFence) {
                  // The atom was a function that may be followed by
                  // an argument, like `\sin(`
                  var smartFence = this.scanSmartFence();

                  if (smartFence) {
                    result = [result, smartFence];
                  }
                }
              }
            }

            if (!info) {
              // An unknown command
              result = new MathAtom(this.parseMode, 'error', '\\' + token.value);
              result.latex = '\\' + token.value;
            }
          }
        }
      } else if (token.type === 'literal') {
        var _info = _definitions.default.getInfo(token.value, this.parseMode, this.macros);

        if (_info) {
          var _style = _objectSpread({}, this.style);

          if (_info.baseFontFamily) _style.baseFontFamily = _info.baseFontFamily;
          result = new MathAtom(this.parseMode, _info.type, _info.value || token.value, _style);

          if (_info.isFunction) {
            result.isFunction = true;
          }
        } else {
          result = new MathAtom(this.parseMode, this.parseMode === 'math' ? 'mord' : '', token.value, this.style);
        }

        result.latex = _definitions.default.matchCodepoint(this.parseMode, token.value.codePointAt(0));

        if (_info && _info.isFunction && this.smartFence) {
          // The atom was a function that may be followed by
          // an argument, like `f(`.
          var _smartFence = this.scanSmartFence();

          if (_smartFence) {
            result = [result, _smartFence];
          }
        }
      } else if (token.type === '#') {
        // Parameter token in an implicit group (not as a parameter)
        if (token.value === '?') {
          // '#?' indicates that a placeholder should be used
          result = this.placeholder();
        } else if (this.args) {
          result = this.args[token.value] || null;

          if (Array.isArray(result) && result.length === 1) {
            result = result[0];
          } else if (Array.isArray(result)) {
            var group = new MathAtom(this.parseMode, 'group');
            group.body = result;
            result = group;
          } else {
            // If there is no argument value specified, use a placeholder
            result = this.placeholder();
          }
        }
      } else {
        console.warn('Unexpected token type "' + token.type + '", value ="' + token.value + '"');
      }

      return result;
    }
    /**
     * Attempt to scan the macro name and return an atom list if successful.
     * Otherwise, it wasn't a macro.
     */

  }, {
    key: "scanMacro",
    value: function scanMacro(macro) {
      if (!this.macros || !this.macros[macro]) return null;
      var args = {};
      var def;
      var argCount = 0;

      if (typeof this.macros[macro] === 'string') {
        def = this.macros[macro]; // Let's see if there are arguments in the definition.

        if (/(^|[^\\])#1/.test(def)) argCount = 1;
        if (/(^|[^\\])#2/.test(def)) argCount = 2;
        if (/(^|[^\\])#3/.test(def)) argCount = 3;
        if (/(^|[^\\])#4/.test(def)) argCount = 4;
        if (/(^|[^\\])#5/.test(def)) argCount = 5;
        if (/(^|[^\\])#6/.test(def)) argCount = 6;
        if (/(^|[^\\])#7/.test(def)) argCount = 7;
        if (/(^|[^\\])#8/.test(def)) argCount = 8;
        if (/(^|[^\\])#9/.test(def)) argCount = 9;
      } else {
        def = this.macros[macro].def;
        argCount = this.macros[macro].args || 0;
      }

      for (var i = 1; i <= argCount; i++) {
        args[i] = this.scanArg();
      } // Carry forward the placeholder argument, if any.


      if (this.args && typeof this.args['?'] === 'string') {
        args['?'] = this.args['?'];
      } // Group the result of the macro expansion, and set the
      // captureSelection attribute so that it is handled as an unbreakable
      // unit


      var atom = new MathAtom(this.parseMode, 'group', parseTokens(_lexer.default.tokenize(def), this.parseMode, args, this.macros));
      atom.captureSelection = true;
      atom.latex = '\\' + macro;
      var argString = '';

      for (var _i = 1; _i <= argCount; _i++) {
        argString += '{';

        if (Array.isArray(args[_i])) {
          for (var j = 0; j < args[_i].length; j++) {
            argString += args[_i][j].latex;
          }
        }

        argString += '}';
      }

      atom.latex += argString ? argString : '';
      return atom;
    }
    /**
     * Make a MathAtom for the current token or token group and
     * add it to the parser's current mathList
     * @method module:core/parser#Parser#parseAtom
     * @private
     */

  }, {
    key: "parseAtom",
    value: function parseAtom() {
      var result = this.scanEnvironment() || this.scanModeShift() || this.scanModeSet() || this.scanGroup() || this.scanLeftRight();
      if (!result && (this.parseSupSub() || this.parseLimits())) return true;
      if (!result) result = this.scanToken(); // If we have an atom to add, push it at the end of the current math list
      // We could have no atom for tokens that were skipped, a ' ' in mathmode
      // for example

      if (Array.isArray(result)) {
        this.mathList = this.mathList.concat(result);
      } else if (result) {
        this.mathList.push(result);
      }

      return result !== null;
    }
  }]);

  return Parser;
}();
/**
 * Given an array of tokens returned by the lexer, return a corresponding
 * math list (array of atoms).
 * @param {object[]} tokens
 * @param {string} [parseMode='math']
 * @param {string[]} [args={}] - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param {object} [macro={}] Dictionary defining macros
 * @param {boolean} [smartFence=false] If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 * @return {object[]} An array of MathAtom
 * @method module:core/parser#parseTokens
 * @private
 */


function parseTokens(tokens, parseMode, args, macros, smartFence) {
  var mathlist = [];
  var parser = new Parser(tokens, args, macros);
  parser.parseMode = parseMode || 'math'; // other possible values: 'text', 'color', etc...

  if (smartFence) parser.smartFence = true;

  while (!parser.end()) {
    mathlist = mathlist.concat(parser.scanImplicitGroup());
  }

  return mathlist;
} // Export the public interface for this module


var _default = {
  Parser: Parser,
  parseTokens: parseTokens
};
exports.default = _default;